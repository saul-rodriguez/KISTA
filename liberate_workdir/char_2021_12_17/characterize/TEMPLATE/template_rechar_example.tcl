# TEMPLATE/template_rechar_example.tcl : template Tcl file generated by Liberate 17.1.0.496 on Wed Apr 18 12:43:40 EDT 2018

set_var slew_lower_rise 0.3
set_var slew_lower_fall 0.3
set_var slew_upper_rise 0.7
set_var slew_upper_fall 0.7

set_var measure_slew_lower_rise 0.3
set_var measure_slew_lower_fall 0.3
set_var measure_slew_upper_rise 0.7
set_var measure_slew_upper_fall 0.7

set_var delay_inp_rise 0.5
set_var delay_inp_fall 0.5
set_var delay_out_rise 0.5
set_var delay_out_fall 0.5

set_var def_arc_msg_level 0
set_var process_match_pins_to_ports 1
set_var max_transition 1.5e-09
set_var min_transition 2.5e-10
set_var min_output_cap 1.5e-14

set cells { \
  DFFX1 \
  INVX1 \
  NOR2X1 \
}

define_template -type delay \
         -index_1 {0.25 0.5 0.75 1.25 1.5 } \
         -index_2 {0.015 0.05 0.15 0.3 0.6 } \
         delay_template_5x5

define_template -type constraint \
         -index_1 {0.25 0.75 1.5 } \
         -index_2 {0.25 0.75 1.5 } \
         constraint_template_3x3

define_template -type power \
         -index_1 {0.25 0.5 0.75 1.25 1.5 } \
         -index_2 {0.015 0.05 0.15 0.3 0.6 } \
         power_template_5x5

if {[ALAPI_active_cell "DFFX1"]} {
define_cell \
       -clock { CK } \
       -input { D } \
       -output { Q QN } \
       -pinlist { D CK Q QN } \
       -delay delay_template_5x5 \
       -power power_template_5x5 \
       -constraint constraint_template_3x3 \
       DFFX1

define_leakage -when "(CK * D * !(Q) * QN)" DFFX1
define_leakage -when "(CK * D * Q * !(QN))" DFFX1
define_leakage -when "(CK * !(D) * !(Q) * QN)" DFFX1
define_leakage -when "(CK * !(D) * Q * !(QN))" DFFX1
define_leakage -when "(!(CK) * D * !(Q) * QN)" DFFX1
define_leakage -when "(!(CK) * D * Q * !(QN))" DFFX1
define_leakage -when "(!(CK) * !(D) * !(Q) * QN)" DFFX1
define_leakage -when "(!(CK) * !(D) * Q * !(QN))" DFFX1

# power arcs from  => D  hidden
define_arc \
       -type hidden \
       -when "(CK * Q * !(QN)) + (CK * !(Q) * QN)" \
       -vector {Rxxx} \
       -pin D \
       DFFX1

# power arcs from  => D  hidden
define_arc \
       -type hidden \
       -when "(CK * Q * !(QN)) + (CK * !(Q) * QN)" \
       -vector {Fxxx} \
       -pin D \
       DFFX1

define_arc \
       -type hidden \
       -when "(!(CK) * Q * !(QN)) + (!(CK) * !(Q) * QN)" \
       -vector {Rxxx} \
       -pin D \
       DFFX1

define_arc \
       -type hidden \
       -when "(!(CK) * Q * !(QN)) + (!(CK) * !(Q) * QN)" \
       -vector {Fxxx} \
       -pin D \
       DFFX1

# constraint arcs from CK => D  hold_rising
define_arc \
       -type hold \
       -vector {RRxx} \
       -related_pin CK \
       -pin D \
       DFFX1

# constraint arcs from CK => D  hold_rising
define_arc \
       -type hold \
       -vector {FRxx} \
       -related_pin CK \
       -pin D \
       DFFX1

define_arc \
       -type setup \
       -vector {RRxx} \
       -related_pin CK \
       -pin D \
       DFFX1

define_arc \
       -type setup \
       -vector {FRxx} \
       -related_pin CK \
       -pin D \
       DFFX1

# power arcs from  => CK  hidden
define_arc \
       -type hidden \
       -when "(D * Q * !(QN))" \
       -vector {xFxx} \
       -pin CK \
       DFFX1

# power arcs from  => CK  hidden
define_arc \
       -type hidden \
       -when "(D * !(Q) * QN)" \
       -vector {xRxx} \
       -pin CK \
       DFFX1

define_arc \
       -type hidden \
       -when "(D * !(Q) * QN)" \
       -vector {xFxx} \
       -pin CK \
       DFFX1

define_arc \
       -type hidden \
       -when "(!(D) * Q * !(QN))" \
       -vector {xRxx} \
       -pin CK \
       DFFX1

define_arc \
       -type hidden \
       -when "(!(D) * Q * !(QN))" \
       -vector {xFxx} \
       -pin CK \
       DFFX1

define_arc \
       -type hidden \
       -when "(!(D) * !(Q) * QN)" \
       -vector {xFxx} \
       -pin CK \
       DFFX1

# constraint arcs from CK => CK  min_pulse_width
define_arc \
       -type min_pulse_width \
       -vector {xRxx} \
       -related_pin CK \
       -pin CK \
       DFFX1

# constraint arcs from CK => CK  min_pulse_width
define_arc \
       -type min_pulse_width \
       -vector {xFxx} \
       -related_pin CK \
       -pin CK \
       DFFX1

# delay arcs from CK => Q non_unate rising_edge
define_arc \
       -type edge \
       -vector {xRRx} \
       -related_pin CK \
       -pin Q \
       DFFX1

# delay arcs from CK => Q non_unate rising_edge
define_arc \
       -type edge \
       -vector {xRFx} \
       -related_pin CK \
       -pin Q \
       DFFX1

# delay arcs from CK => QN non_unate rising_edge
define_arc \
       -type edge \
       -vector {xRxR} \
       -related_pin CK \
       -pin QN \
       DFFX1

# delay arcs from CK => QN non_unate rising_edge
define_arc \
       -type edge \
       -vector {xRxF} \
       -related_pin CK \
       -pin QN \
       DFFX1

}
if {[ALAPI_active_cell "INVX1"]} {
define_cell \
       -input { A } \
       -output { Y } \
       -pinlist { A Y } \
       -delay delay_template_5x5 \
       -power power_template_5x5 \
       INVX1

define_leakage -when "(A * !(Y))" INVX1
define_leakage -when "(!(A) * Y)" INVX1

# delay arcs from A => Y negative_unate combinational
define_arc \
       -vector {FR} \
       -related_pin A \
       -pin Y \
       INVX1

# delay arcs from A => Y negative_unate combinational
define_arc \
       -vector {RF} \
       -related_pin A \
       -pin Y \
       INVX1

}
if {[ALAPI_active_cell "NOR2X1"]} {
define_cell \
       -input { A1 A2 } \
       -output { Y } \
       -pinlist { A1 A2 Y } \
       -delay delay_template_5x5 \
       -power power_template_5x5 \
       NOR2X1

define_leakage -when "(A1 * A2 * !(Y))" NOR2X1
define_leakage -when "(A1 * !(A2) * !(Y))" NOR2X1
define_leakage -when "(!(A1) * A2 * !(Y))" NOR2X1
define_leakage -when "(!(A1) * !(A2) * Y)" NOR2X1

# power arcs from  => A1  hidden
define_arc \
       -type hidden \
       -when "(A2 * !(Y))" \
       -vector {Rxx} \
       -pin A1 \
       NOR2X1

# power arcs from  => A1  hidden
define_arc \
       -type hidden \
       -when "(A2 * !(Y))" \
       -vector {Fxx} \
       -pin A1 \
       NOR2X1

# power arcs from  => A2  hidden
define_arc \
       -type hidden \
       -when "(A1 * !(Y))" \
       -vector {xRx} \
       -pin A2 \
       NOR2X1

# power arcs from  => A2  hidden
define_arc \
       -type hidden \
       -when "(A1 * !(Y))" \
       -vector {xFx} \
       -pin A2 \
       NOR2X1

# delay arcs from A1 => Y negative_unate combinational
define_arc \
       -vector {FxR} \
       -related_pin A1 \
       -pin Y \
       NOR2X1

# delay arcs from A1 => Y negative_unate combinational
define_arc \
       -vector {RxF} \
       -related_pin A1 \
       -pin Y \
       NOR2X1

# delay arcs from A2 => Y negative_unate combinational
define_arc \
       -vector {xFR} \
       -related_pin A2 \
       -pin Y \
       NOR2X1

# delay arcs from A2 => Y negative_unate combinational
define_arc \
       -vector {xRF} \
       -related_pin A2 \
       -pin Y \
       NOR2X1

}
